# Оновлений Аналіз Ефективності Методів Міжпроцесної Комунікації (IPC)

## Вступ

Для оцінки продуктивності різних методів IPC було проведено серію експериментів з використанням таких методів:

- mmap (у режимах shared та private)
- shared_memory
- pipe
- fifo
- file
- message_queue
- unix_socket

Тестування здійснювалося з різними розмірами повідомлень (64 та 1024 байти) та кількістю повідомлень (100 та 1000). Особлива увага приділялася впливу синхронізації на продуктивність.

## Опис Методів, Реалізація та Результати Тестування

### 1. mmap

mmap дозволяє відображати файли або пристрої у пам'ять процесу, що забезпечує ефективний доступ до даних. У експериментах використовувалися два режими:

- **Shared (спільний)**: Область пам'яті відображається спільно між процесами.
- **Private (приватний)**: Кожен процес має свою копію області пам'яті; зміни не впливають на інші процеси.

#### Реалізація:

- Використовували функцію mmap для створення відображеної області пам'яті.
- Синхронізація між процесами не забезпечувалася, що дозволяло експериментально оцінити базову пропускну здатність.
- Процеси читали та писали дані безпосередньо в область пам'яті.

#### Результати:

| Розмір повідомлення (байт) | Кількість повідомлень | Режим    | Пропускна здатність (байт/сек) |
|----------------------------|------------------------|----------|-------------------------------|
| 64                         | 100                    | Shared   | 237,037,037.04                |
| 64                         | 100                    | Private  | 653,061,224.49                |
| 64                         | 1000                   | Shared   | 670,157,068.06                |
| 64                         | 1000                   | Private  | 426,666,666.67                |
| 1024                        | 100                    | Shared   | 604,843,473.12                |
| 1024                        | 100                    | Private  | 845,582,163.50                |
| 1024                        | 1000                   | Shared   | 567,658,961.14                |
| 1024                        | 1000                   | Private  | 738,550,306.53                |

#### Проміжні висновки:

- Відсутність синхронізації дозволила досягти високої пропускної здатності.
- Режим private демонструє вищу продуктивність, оскільки виключає накладні витрати на синхронізацію та оновлення спільної пам'яті.
- **Ризики**: Відсутність синхронізації може призвести до race conditions у реальних додатках, де процеси взаємодіють непередбачуваним чином.

### 2. Shared Memory

Метод спільної пам'яті (shared_memory) дозволяє різним процесам отримувати доступ до однієї області пам'яті.

#### Реалізація:

- Використовували `shm_open` для створення сегменту спільної пам'яті.
- Відображали пам'ять у процеси за допомогою `mmap`.
- Синхронізація не забезпечувалася, процеси читали та писали дані без координації.

#### Оновлені Результати:

| Розмір повідомлення (байт) | Кількість повідомлень | Пропускна здатність (байт/сек) |
|----------------------------|------------------------|-------------------------------|
| 64                         | 100                    | 274,678,111.59                |
| 64                         | 1000                   | 286,097,451.94                |
| 1024                        | 100                    | 491,362,763.92                |
| 1024                        | 1000                   | 340,992,227.44                |

#### Проміжні висновки:

- Відсутність синхронізації значно підвищила продуктивність порівняно з попередніми тестами.
- **Ризики**: Race conditions залишаються, що може бути критичним у реальних застосуваннях.

### 3. Pipe

Канали (pipe) забезпечують однонаправлену комунікацію між процесами через файлові дескриптори.

#### Реалізація:

- Створення каналу за допомогою `pipe()`.
- Використання блокуючого режиму передачі даних.
- Читання та запис через `read()` та `write()`.

#### Результати:

| Розмір повідомлення (байт) | Кількість повідомлень | Пропускна здатність (байт/сек) | Ємність каналу (повідомлень) |
|----------------------------|------------------------|-------------------------------|------------------------------|
| 64                         | 100                    | 17,704,011.07                 | 401                          |
| 64                         | 1000                   | 15,122,523.16                 | 401                          |
| 1024                        | 100                    | 322,216,243.60                | 401                          |
| 1024                        | 1000                   | 196,390,631.71                | 401                          |

#### Проміжні висновки:

- Ємність каналу обмежена (401 повідомлення), після чого канал переповнюється.
- Продуктивність нижча, ніж у методів без синхронізації, але достатня для багатьох застосувань.

### 4. FIFO (Named Pipe)

Іменовані канали (fifo) дозволяють комунікацію між незв'язаними процесами.

#### Реалізація:

- Створення FIFO за допомогою `mkfifo()`.
- Використання `open()`, `read()`, `write()` для обміну даними.
- Синхронізація не забезпечувалася; канали самі по собі забезпечують послідовність даних.

#### Результати:

| Розмір повідомлення (байт) | Кількість повідомлень | Пропускна здатність (байт/сек) |
|----------------------------|------------------------|-------------------------------|
| 64                         | 100                    | 12,952,869.77                 |
| 64                         | 1000                   | 12,410,802.21                 |
| 1024                        | 100                    | 461,469,130.24                |
| 1024                        | 1000                   | 412,238,491.24                |

#### Проміжні висновки:

- Продуктивність схожа з pipe, але трохи нижча.
- Підходить для простих сценаріїв, де високої швидкості не вимагається.

### 5. File

Передача даних через файли на диску.

#### Реалізація:

- Використання `fopen()`, `fwrite()`, `fread()`, `fclose()`.
- Дані записувалися у файл, потім читалися іншим процесом.

#### Результати:

| Розмір повідомлення (байт) | Кількість повідомлень | Пропускна здатність (байт/сек) |
|----------------------------|------------------------|-------------------------------|
| 64                         | 100                    | 1,433,242.90                  |
| 64                         | 1000                   | 6,347,697.51                  |
| 1024                        | 100                    | 26,313,098.12                 |
| 1024                        | 1000                   | 106,413,977.81                |

#### Проміжні висновки:

- Найнижча пропускна здатність через накладні витрати на дискові операції.
- Підходить для збереження даних, але не для швидкої комунікації.

### 6. Message Queue

POSIX черги повідомлень забезпечують асинхронну передачу повідомлень з пріоритетами.

#### Реалізація:

- Створення черги за допомогою `mq_open()`.
- Використання `mq_send()` та `mq_receive()`.
- Синхронізація забезпечується системою черг, немає необхідності у додаткових механізмах.

#### Результати:

| Розмір повідомлення (байт) | Кількість повідомлень | Пропускна здатність (байт/сек) | Максимальна ємність (повідомлень) |
|----------------------------|------------------------|-------------------------------|-----------------------------------|
| 64                         | 100                    | 15,403,165.83                 | 20                                |
| 64                         | 1000                   | 24,625,812.70                 | 20                                |
| 1024                        | 100                    | 276,010,781.67                | 20                                |
| 1024                        | 1000                   | 380,273,462.67                | 20                                |

#### Проміжні висновки:

- Обмежена ємність черги (20 повідомлень) може бути перешкодою.
- Висока пропускна здатність при передачі великих повідомлень.

### 7. Unix Socket

Unix сокети забезпечують двосторонню комунікацію між процесами на одній машині.

#### Реалізація:

- Використання `socketpair()` для створення пари сокетів.
- Обмін даними через `send()` та `recv()`.
- Синхронізація не забезпечувалася явно, сокети гарантують послідовність передачі даних.

#### Результати:

| Розмір повідомлення (байт) | Кількість повідомлень | Пропускна здатність (байт/сек) | Ємність каналу (повідомлень) |
|----------------------------|------------------------|-------------------------------|------------------------------|
| 64                         | 100                    | 38,647,342.99                 | 952                          |
| 64                         | 1000                   | 41,020,408.29                 | 952                          |
| 1024                        | 100                    | 439,296,439.30                | 952                          |
| 1024                        | 1000                   | 515,116,713.68                | 952                          |

#### Проміжні висновки:

- Висока пропускна здатність, особливо при великих розмірах повідомлень.
- Сокети автоматично обробляють синхронізацію, що спрощує розробку.


## Загальна Порівняльна Таблиця

| IPC_METHOD      | MESSAGE_SIZE (байт) | MESSAGE_COUNT | THROUGHPUT (байт/сек) | MAX_CAPACITY (повідомлень) |
|-----------------|----------------------|---------------|-----------------------|---------------------------|
| mmap (private)  | 1024                 | 1000          | 738,550,306.53        | N/A                       |
| mmap (shared)   | 1024                 | 1000          | 567,658,961.14        | N/A                       |
| shared_memory   | 1024                 | 1000          | 340,992,227.44        | N/A                       |
| unix_socket     | 1024                 | 1000          | 515,116,713.68        | 952                       |
| fifo            | 1024                 | 1000          | 412,238,491.24        | N/A                       |
| message_queue   | 1024                 | 1000          | 380,273,462.67        | 20                        |
| pipe            | 1024                 | 1000          | 196,390,631.71        | 401                       |
| file            | 1024                 | 1000          | 106,413,977.81        | N/A                       |

## Висновки

- Відсутність синхронізації значно підвищує продуктивність методів mmap та shared_memory, роблячи їх одними з найшвидших методів IPC.
- **Ризик race conditions**: Відсутність синхронізації може призвести до некоректної роботи додатків у багатопотоковому середовищі.
- Unix сокети демонструють високу продуктивність і автоматично забезпечують синхронізацію передачі даних.
- Канали (pipe, fifo) мають середню продуктивність і підходять для простих задач.
- Робота з файлами є найменш ефективною для IPC і не рекомендується для високошвидкісних комунікацій.

## Заключення

Результати показують, що відсутність синхронізації може суттєво підвищити продуктивність, але це може призвести до ризиків некоректної роботи додатків. Тому вибір методу IPC повинен бути обґрунтованим з точки зору вимог до швидкості та надійності.

Для задач, де критично важлива швидкість, і процеси можуть працювати без синхронізації, рекомендується використовувати mmap або shared_memory без додаткових механізмів синхронізації.
Для задач, де важлива надійність та коректність даних, варто використовувати методи з вбудованою синхронізацією, такі як unix_socket, pipe, fifo або message_queue.
